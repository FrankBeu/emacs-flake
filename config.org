#+TITLE: emacs Configuration
* emacsConfiguration
** styleGuide
*** elisp
**** variable-naming
- ~doom/abc~ A public, interactive command, designed to be used via =M-x= or a keybinding.
- ~doom:abc~ A public evil operator, motion or command.
- ~doom|abc~ A public, non-interactive function meant to be used as a hook.
- ~doom*abc~ Functions designed to be used as advice for other functions.
- ~abc!~ A public Doom "autodef" function or macro.
  An autodef should always be defined, even if its containing module is disabled
  (i.e. they will not throw a void-function error).
  The purpose of this is to avoid peppering module configs with conditionals or ~after!~ blocks before using their APIs.
  They should noop if their module is disabled, and should be zero-cost in the case their module is disabled.
  Autodefs usually serve to configure Doom or a module. [and are usually syntactic sugar]
- Functions prefixed with ~+abc...~ belong to a module, e.g. ~+emacs-lisp|init-hook~ is a hook function in the ~lang/emacs-lisp~ module.
- ~=abc~ An interactive command that invokes an app module.
*** org-mode
**** =verbatim=    ---   ~code~   ::    `=verbatim=' and `~code~'
=●= == key-sequences and text, paths or file names - markup rather than code
~●~ ~~ functions and variables commands
***** TODO check project
** package-loading
#+begin_src elisp
  (require 'package)
#+end_src
*** optional. makes unpure packages archives unavailable
#+begin_src elisp
  (setq package-archives nil)
#+end_src
*** use-package
#+begin_src elisp
  (setq package-enable-at-startup nil)
  ;; (package-initialize 'no-activate)
  (package-initialize)
  (eval-when-compile
    (require 'use-package))
#+end_src
** tangling
#+INCLUDE: "./tangling/tangling.org"
** debugging
#+begin_src elisp
  ;; (setq debug-on-error t)
  ;; (setq debug-ignored-error t)
  ;;;; nixos-packages
#+end_src
** functions: loadConfig
#+begin_src elisp
  (defun fb*getPathToConfigFile (filename)
    "Returns concatenation of \"HOME\" , \".emacs.d/\" and the passed \"filename\"."
    (expand-file-name filename (expand-file-name ".emacs.d" (getenv "HOME"))))
  (defun fb*loadConfigFile (configFileName)
    "Load the config-file associated with the passed configFileName if it exists."
    (let ((pathToConfigFile (fb*getPathToConfigFile configFileName)))
      (if (file-readable-p pathToConfigFile) (load pathToConfigFile) (message "WARNING: CONFIG-FILE NOT FOUND: %s" pathToConfigFile))
      ))
#+end_src
*** TODO remove
** INCLUDES
~order matters!~
*** DONE completion
#+INCLUDE: "./completion/completion.org"
*** DONE evil
#+INCLUDE: "./evil/evil.org"
*** DONE global
#+INCLUDE: "./global/global.org"
*** DONE languages
#+INCLUDE: "./languages/languages.org"
*** DONE modeline
#+INCLUDE: "./modeline/modeline.org"
*** TODO orgmode
,#+INCLUDE: "./orgmode/orgmode.org"
#+begin_src elisp
  (fb*loadConfigFile "orgmode/0-orgmode.el")
#+end_src
*** TODO project
,#+INCLUDE: "./project/project.org"
#+begin_src elisp
  (fb*loadConfigFile "project/0-project.el")
#+end_src
*** DONE tex
#+INCLUDE: "./tex/tex.org"
*** DONE themes
#+INCLUDE: "./themes/themes.org"
*** DONE keys
#+INCLUDE: "./keys/keys.org"
